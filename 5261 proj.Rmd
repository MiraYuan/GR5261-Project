---
title: "5261project"
author: "Jiayi Yuan"
date: '2022-04-20'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Descriptive Statistics
```{r}
library(readxl)
library(moments)
library(reshape)
library(corrgram)
library(tidyr)
library(tseries)
library(fGarch)
asset <- read_xlsx("12Assetdata.xlsx", sheet = "Price")
return <- read_xlsx("12Assetdata.xlsx", sheet = "Return")
asset[,-1] <- round(asset[,-1], 4)
asset$Date <- as.Date(asset$Date)
return$Date <- as.Date(return$Date)
```

### Means SDs Skewness  Kurtosis Betas
```{r}
means <- sapply(asset[,2:14], mean)
means
means_r <- sapply(return[,2:14], mean)
means_r

### SDs
sds <- sapply(asset[,2:14], sd)
sds
sds_r <- sapply(return[,2:14], sd)
sds_r

### Skewness
skews <- sapply(asset[,2:14], skewness)
skews
skews_r <- sapply(return[,2:14], skewness)
skews_r

### Kurtosis
kurtosis <- sapply(asset[,2:14], kurtosis)
kurtosis
kurtosis_r <- sapply(return[,2:14], kurtosis)
kurtosis_r

### Betas
betas <- list()
for (i in 2:13){
  betas[i-1] <- lm(unlist(return[,i])-return$`Treasury Bill 3 month (rf)`~
                 return$`S&P500`- return$`Treasury Bill 3 month (rf)`)$coefficients[2]
}
names <- colnames(asset)[2:13]
rbind(names, unlist(betas))
```

### Plots
```{r}
par(mfrow = c(3,3))
### Price
for(i in 2:13){
  plot(asset$Date, unlist(asset[,i]), type = "l", col = i, 
       main = paste(colnames(asset[,i])," price"))
}

## Return
for(i in 2:13){
  plot(return$Date, unlist(return[,i]), type = "l", col = i,
       main = paste(colnames(return[,i])," return"))
  abline(h=0)
}
```

### Equity curve
```{r}
par(mfrow = c(3,3))
for(i in 2:13){
  plot(x = unlist(return$Date),y = unlist(cumsum(return[,i])), type="l", 
       main = colnames(return[,i]), xlab = "Date", ylab = "Return") 
}
```

### Stationary Test
```{r}
### Stationary Test
par(mfrow = c(2,4))
for(i in 2:14){
  acf(unlist(return[,i]),lag.max = length(return$MSFT),
         xlab = "lag #", ylab = 'ACF', main=' ')
}
```

### Hist, Boxplot, qqplot
```{r fig.width=10, fig.height=10}
### Hist, Boxplot, qqplot
par(mfrow = c(3,3))
for(i in 2:14){
  hist(unlist(return[,i]), freq = FALSE,
       main = colnames(return)[i], xlab = "Return")
  lines(density(unlist(return[,i])))
  boxplot(unlist(return[,i]), main = colnames(return)[i])
  qqnorm(unlist(return[,i]), pch = 1, main = colnames(return)[i])
  qqline(unlist(return[,i]), lwd = 2)
}
```

### Distributions
```{r warning=FALSE}
#### t
namesd <- data.frame(colnames(asset[1,2:13]))
tdis <- rep(NA, 12)
normal <- rep(NA, 12)
ged <- rep(NA, 12)

tdis_fun <- function(return) {
  start = c(mean(return), sd(return), 5)
  loglik_t = function(beta)
    sum(-dt((return - beta[1]) / beta[2],
            beta[3], log = TRUE) + log(beta[2]))
  fit_t = optim(
    start,
    loglik_t,
    hessian = T,
    method = "L-BFGS-B",
    lower = c(-1, 0.001, 1)
  )
  AIC_t = 2 * fit_t$value + 2 * 3
  #return(AIC_t)
  return(fit_t$value)
}

for (i in 2:13){
  tdis[i-1] <- lapply(return[,i], tdis_fun)
}
tdis <- data.frame(unlist(tdis))

#### normal
ndis_fun <- function(return) {
  AIC_n <- 2 * snormFit(return, hessian = TRUE)$objective + 2 * 3
  AIC_n
}
for(i in 2:13){
  normal[i-1] <- lapply(return[,i], ndis_fun)
}
normal <- data.frame(unlist(normal))

#### ged
ged_fun <- function(return) {
  AIC_ged <- 2 * gedFit(return, hessian = TRUE)$objective + 2 * 3
  AIC_ged
}
for(i in 2:13){
  ged[i-1] <- lapply(return[,i], ged_fun)
}
ged <- data.frame(unlist(ged)) 

dis_df <- cbind(namesd,tdis,normal,ged)
dis_df
```

### Sharpe's Slope ??
```{r}
# sharpes <- data.frame(matrix(ncol=13, nrow = 98))
# colnames(sharpes) <- colnames(return[1,2:14])
# 
# for(i in 2:14){
#   sharpes[,i-1] = (unlist(return[,i])-unlist(return[,15])/100)/sds_r[i-1]
# }
# max(sharpes[,1])
names_sh <- data.frame(colnames(return[1,2:14]))
sharpes_list <- rep(NA, 13)
for(i in 2:14){
  sharpes_list[i-1] = (mean(unlist(return[,i]))-mean(unlist(return[,15]))/100)/sd(unlist(return[,i]))
}
sharpes_list <- data.frame(sharpes_list)
shar_df <- cbind(names_sh,sharpes_list)
shar_df
```

### M to Y
```{r}
means_y <- means_r*12
means_y

### SDs
sds_y <- means_r*sqrt(12)
sds_y
```

### Pairewise
```{r fig.width=15, fig.height=15}
pairs(return[,2:14],pch = 19)
```

### Covariance Matrix
```{r}
cov_mat <- cov(return[,2:14])
cov_mat
```

## Portfolio Theory
### With Short Sale
```{r}
library(quadprog)
R = 100*return[,2:13]
mean_p <- apply(R,2,mean)
cov_p <- cov(R)
sd_vect_p <- sqrt(diag(cov_p))
# min(mean_p)
# max(mean_p)
### With shortsale
M_p = length(mean_p)
Amat_p <- cbind(rep(1,M_p),mean_p)
mu_P = seq(0.07, 5.4, length = 300)
# Target portfolio means for the expect portfolio return
sd_P = mu_P # set up storage for std dev's of portfolio returns
weights_p = matrix(0, nrow = 300, ncol = M_p) # storage for return
for (i in 1:length(mu_P)) { # find the optimal portfolios
  bvec_p <- c(1, mu_P[i])
  result_p = solve.QP(Dmat = 2 * cov_p, dvec = rep(0, M_p), Amat = Amat_p, 
                    bvec = bvec_p, meq = 2)
  sd_P[i] = sqrt(result_p$value)
  weights_p[i, ] = result_p$solution
}
plot(sd_P, mu_P, type = "l", xlim = c(0,15), ylim = c(0, 6), lty = 3, lwd = 2) 
# plot efficient frontier (and inefficient portfolios below the min var portfolio)
mufree_p = mean(return$`Treasury Bill 3 month (rf)`)# input value of risk-free interest rate
points(0, mufree_p, cex = 4, pch = "*") # show risk-free asset
sharpe_p = (mu_P - mufree_p) / sd_P # compute Sharpes ratios
ind_p = (sharpe_p == max(sharpe_p)) # Find maximum Sharpes ratio
#weights_p[ind_p,] # print the weights of the tangency portfolio
lines(c(0, 15), mufree_p + c(0, 15) * (mu_P[ind_p] - mufree_p) / sd_P[ind_p], lwd = 4, 
      lty = 1, col = "blue") # show line of optimal portfolios
points(sd_P[ind_p], mu_P[ind_p], cex = 4, pch = "*") # tangency portfolio
ind2_p = (sd_P == min(sd_P)) # find the minimum variance portfolio
points(sd_P[ind2_p], mu_P[ind2_p], cex = 2, pch = "+") # min var portfolio
ind3_p = (mu_P > mu_P[ind2_p])
lines(sd_P[ind3_p], mu_P[ind3_p], type = "l", xlim = c(0, 25), ylim = c(0,30),
      lwd = 3, col = 'red') # plot the efficient frontier
for(i in 1:12){
  text(sd_vect_p[i], mean_p[i],colnames(return[,i+1]), cex=0.8)
}

### MVP
(mvp_meanreturn <- mu_P[ind2_p])
(mvp_sd <- sd_P[ind2_p])
weights_mvp <- weights_p[ind2_p,]
weights_mvp <- t(data.frame(weights_mvp))
colnames(weights_mvp) <- colnames(return[2:13])
weights_mvp
(mvp_meanreturn_ann <- mvp_meanreturn*12)
(mvp_sd_ann <- mvp_sd*sqrt(12))

### Efficient Portfolio Frontier
EPF_mean <- mu_P[ind3_p]
EPF_sd <- sd_P[ind3_p]

### Tangency Portfolio
(tan_meanreturn <- mu_P[ind_p])
(tan_sd <- sd_P[ind_p])
(tan_var <- tan_sd^2)
(tan_sharpes <- (tan_meanreturn-mufree_p)/tan_sd)
```

#### VaR&ES
```{r warning=FALSE}
### Tail dependence can be seen among the assets, therefore we can fit
### our portfolio with multivariate t-distribution.

## MVP VaR&ES
library(MASS)
alpha = 0.05
return_mvp <- rowSums(data.frame(
  weights_mvp[1] * return[, 2],
  weights_mvp[2] * return[, 3],
  weights_mvp[3] * return[, 4],
  weights_mvp[4] * return[, 5],
  weights_mvp[5] * return[, 6],
  weights_mvp[6] * return[, 7],
  weights_mvp[7] * return[, 8],
  weights_mvp[8] * return[, 9],
  weights_mvp[9] * return[, 10],
  weights_mvp[10] * return[, 11],
  weights_mvp[11] * return[, 12],
  weights_mvp[12] * return[, 13]))
fitt_mvp = fitdistr(return_mvp,"t")
param_mvp = as.numeric(fitt_mvp$estimate)
mean_mvpfit = param_mvp[1]
df_mvpfit = param_mvp[3]
sd_mvpfit = param_mvp[2] * sqrt((df_mvpfit) / (df_mvpfit - 2))
lambda_mvpfit = param_mvp[2]
qalpha_mvp = qt(alpha, df = df_mvpfit)
VaR_par_mvp = -100000 * (mean_mvpfit + lambda_mvpfit * qalpha_mvp)
es1_mvp = dt(qalpha_mvp, df = df_mvpfit) / (alpha)
es2_mvp=(df_mvpfit+qalpha_mvp^2)/(df_mvpfit-1)
es3_mvp=-mean_mvpfit+lambda_mvpfit*es1_mvp*es2_mvp
ES_par_mvp = 100000*es3_mvp
VaR_par_mvp
ES_par_mvp


## Asset VaR
S0 = 100000
qnalpha = qnorm(0.05)

### MSFT
q_msft = as.numeric(quantile(return$MSFT, alpha))
VAR_msft = -S0 * q_msft
#VAR_msft

### TSLA
fit_tsla <- fitdistr(return$TSLA, "normal")
param_tsla = as.numeric(fit_tsla$estimate)
mean_tsla = param_tsla[1]
sd_tsla = param_tsla[2]
VAR_tsla = -S0*(mean_tsla+qnalpha*sd_tsla)
#VAR_tsla

### AAPL
fit_aapl <- fitdistr(return$AAPL, "normal")
param_aapl = as.numeric(fit_aapl$estimate)
mean_aapl = param_aapl[1]
sd_aapl = param_aapl[2]
VAR_aapl = -S0*(mean_aapl+qnalpha*sd_aapl)
#VAR_aapl

### TWTR
fit_twtr <- fitdistr(return$TWTR, "normal")
param_twtr = as.numeric(fit_twtr$estimate)
mean_twtr = param_twtr[1]
sd_twtr = param_twtr[2]
VAR_twtr = -S0*(mean_twtr+qnalpha*sd_twtr)
#VAR_twtr

### AMZN
fit_amzn <- fitdistr(return$AMZN, "normal")
param_amzn = as.numeric(fit_amzn$estimate)
mean_amzn = param_amzn[1]
sd_amzn = param_amzn[2]
VAR_amzn = -S0*(mean_amzn+qnalpha*sd_amzn)
#VAR_amzn

### FB
q_fb = as.numeric(quantile(return$FB, alpha))
VAR_fb = -S0 * q_fb
#VAR_fb

### NFLX
q_nflx = as.numeric(quantile(return$NFLX, alpha))
VAR_nflx = -S0 * q_nflx
#VAR_nflx

### AAL
q_aal = as.numeric(quantile(return$AAL, alpha))
VAR_aal = -S0 * q_aal
#VAR_aal

### DAL
q_dal = as.numeric(quantile(return$DAL, alpha))
VAR_dal = -S0 * q_dal
#VAR_dal

### BAC
q_bac = as.numeric(quantile(return$BAC, alpha))
VAR_bac = -S0 * q_bac
#VAR_bac

### NVDA
q_nvda = as.numeric(quantile(return$NVDA, alpha))
VAR_nvda = -S0 * q_nvda
#VAR_nvda

### WBD
q_wbd = as.numeric(quantile(return$WBD, alpha))
VAR_wbd = -S0 * q_wbd
#VAR_wbd

VAR_asset <- c(VAR_msft, VAR_tsla, VAR_aapl, VAR_twtr, VAR_amzn, VAR_fb, VAR_nflx,
               VAR_aal, VAR_dal, VAR_bac, VAR_nvda, VAR_wbd)
cbind(names, VAR_asset)
```

#### Assets' Sharpe's Ratios
```{r}
names_sh <- data.frame(colnames(return[1,2:14]))
sharpes_list <- rep(NA, 13)
for(i in 2:14){
  sharpes_list[i-1] = (mean(unlist(return[,i]))-mean(unlist(return[,15]))/100)/sd(unlist(return[,i]))
}
sharpes_list <- data.frame(sharpes_list)
shar_df <- cbind(names_sh,sharpes_list)
shar_df
```

### Without shortshale
```{r}
### Without shortsale
#R = 100*return[,2:13]
#mean_p <- apply(R,2,mean)
#cov_p <- cov(R)
#sd_vect_p <- sqrt(diag(cov_p))
### With shortsale
#M_p = length(mean_p)
Amat_p_noss <- cbind(rep(1,M_p),mean_p, diag(1,nrow=M_p))
mu_P_noss = seq(min(mean_p)+0.0001, max(mean_p)-0.0001, length = 300)
# Target portfolio means for the expect portfolio return
sd_P_noss = mu_P_noss # set up storage for std dev's of portfolio returns
weights_p_noss = matrix(0, nrow = 300, ncol = M_p) # storage for return
for (i in 1:length(mu_P_noss)) { # find the optimal portfolios
  bvec_p_noss <- c(1, mu_P_noss[i], rep(0,M_p))
  result_noss = solve.QP(Dmat = 2 * cov_p, dvec = rep(0, M_p), Amat = Amat_p_noss, 
                    bvec = bvec_p_noss, meq = 2)
  sd_P_noss[i] = sqrt(result_noss$value)
  weights_p_noss[i, ] = result_noss$solution
}
plot(sd_P_noss, mu_P_noss, type = "l", lty = 3, 
     lwd = 2, xlim = c(0,15), ylim = c(0,7)) 
# plot efficient frontier (and inefficient portfolios below the min var portfolio)
#mufree_p = mean(return$`Treasury Bill 3 month (rf)`) # input value of risk-free interest rate
points(0, mufree_p, cex = 4, pch = "*") # show risk-free asset
sharpe_p_noss = (mu_P_noss - mufree_p) / sd_P_noss # compute Sharpes ratios
ind_p_noss = (sharpe_p_noss == max(sharpe_p_noss)) # Find maximum Sharpes ratio
#weights_p[ind_p,] # print the weights of the tangency portfolio
lines(c(0, 15), mufree_p + c(0, 15) * (mu_P_noss[ind_p_noss] - mufree_p) / sd_P_noss[ind_p_noss], lwd = 4, 
      lty = 1, col = "blue") # show line of optimal portfolios
points(sd_P_noss[ind_p_noss], mu_P_noss[ind_p_noss], cex = 4, pch = "*") # tangency portfolio
ind2_p_noss = (sd_P_noss == min(sd_P_noss)) # find the minimum variance portfolio
points(sd_P_noss[ind2_p_noss], mu_P_noss[ind2_p_noss], cex = 2, pch = "+") # min var portfolio
ind3_p_noss = (mu_P_noss > mu_P_noss[ind2_p_noss])
lines(sd_P_noss[ind3_p_noss], mu_P_noss[ind3_p_noss], type = "l",
      lwd = 3, col = 'red') # plot the efficient frontier
for(i in 1:12){
  text(sd_vect_p[i], mean_p[i],colnames(return[,i+1]), cex=0.8)
}

### MVP
(mvp_meanreturn_noss <- mu_P_noss[ind2_p_noss])
(mvp_sd_noss <- sd_P_noss[ind2_p_noss])
weights_mvp_noss <- weights_p_noss[ind2_p_noss,]
weights_mvp_noss <- t(data.frame(weights_mvp_noss))
colnames(weights_mvp_noss) <- colnames(return[2:13])
weights_mvp_noss
(mvp_meanreturn_ann_noss <- mvp_meanreturn_noss*12)
(mvp_sd_ann_noss <- mvp_sd_noss*sqrt(12))

### Efficient Portfolio Frontier
EPF_mean_noss <- mu_P_noss[ind3_p_noss]
EPF_sd_noss <- sd_P_noss[ind3_p_noss]

### Tangency Portfolio
(tan_meanreturn_noss <- mu_P_noss[ind_p_noss])
(tan_sd_noss <- sd_P_noss[ind_p_noss])
(tan_var_noss <- tan_sd_noss^2)
(tan_sharpes_noss <- (tan_meanreturn_noss-mufree_p)/tan_sd_noss)
```














